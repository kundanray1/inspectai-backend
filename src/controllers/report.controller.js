const httpStatus = require('http-status');
const catchAsync = require('../utils/catchAsync');
const ApiError = require('../utils/ApiError');
const { pdfExportService, usageMeteringService } = require('../services');
const { Inspection, Subscription, Report, ReportPreset } = require('../models');
const { getStorage, storagePaths } = require('../lib/storage');
const logger = require('../config/logger');

/**
 * List all reports for the organization
 * @route GET /v1/reports
 */
const listReports = catchAsync(async (req, res) => {
  const { user } = req;
  const { page = 1, limit = 20, status } = req.query;

  const query = { organizationId: user.organizationId };
  
  // Optional status filter
  if (status) {
    query.status = status;
  }

  const skip = (parseInt(page, 10) - 1) * parseInt(limit, 10);

  const [reports, total] = await Promise.all([
    Report.find(query)
      .populate({
        path: 'inspectionId',
        populate: { path: 'propertyId' },
      })
      .sort({ updatedAt: -1 })
      .skip(skip)
      .limit(parseInt(limit, 10)),
    Report.countDocuments(query),
  ]);

  // Enrich reports with expiry info
  const enrichedReports = reports.map(report => {
    const latestVersion = report.versions.find(v => v.version === report.currentVersion);
    let expiryInfo = null;

    if (latestVersion?.generatedAt) {
      const expiry = calculateExpiry(latestVersion.generatedAt);
      expiryInfo = {
        expired: expiry.expired,
        expiresAt: expiry.expiresAt,
        daysRemaining: expiry.daysRemaining,
        hoursRemaining: expiry.hoursRemaining,
      };
    }

    return {
      ...report.toObject(),
      expiryInfo,
      property: report.inspectionId?.propertyId || null,
      inspection: report.inspectionId ? {
        _id: report.inspectionId._id,
        status: report.inspectionId.status,
        roomsCount: report.inspectionId.rooms?.length || 0,
      } : null,
    };
  });

  res.json({
    success: true,
    data: enrichedReports,
    meta: {
      total,
      page: parseInt(page, 10),
      limit: parseInt(limit, 10),
      totalPages: Math.ceil(total / parseInt(limit, 10)),
    },
  });
});

/**
 * Get report by inspection ID
 * @route GET /v1/reports/inspection/:inspectionId
 */
const getReportByInspection = catchAsync(async (req, res) => {
  const { inspectionId } = req.params;
  const { user } = req;

  const report = await Report.findOne({
    inspectionId,
    organizationId: user.organizationId,
  });

  if (!report) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report not found for this inspection');
  }

  res.json({
    success: true,
    data: report,
  });
});

/**
 * Create/generate report for an inspection
 * @route POST /v1/reports/inspection/:inspectionId
 */
const createReport = catchAsync(async (req, res) => {
  const { inspectionId } = req.params;
  const { title, summary } = req.body;
  const { user } = req;

  // Check if inspection exists and belongs to user's org
  // Note: rooms is embedded in inspection, not a reference, so only populate propertyId
  const inspection = await Inspection.findOne({
    _id: inspectionId,
    organizationId: user.organizationId,
  }).populate('propertyId');

  if (!inspection) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Inspection not found');
  }

  // Check if report already exists
  let report = await Report.findOne({
    inspectionId,
    organizationId: user.organizationId,
  });

  if (report) {
    // Add new version
    const newVersion = {
      version: report.currentVersion + 1,
      title: title || `Inspection Report v${report.currentVersion + 1}`,
      summary: summary || 'Report generated by InspectAI',
      generatedAt: new Date(),
      generatedBy: user._id,
      watermark: true, // Will be updated based on subscription
    };
    report.versions.push(newVersion);
    report.currentVersion += 1;
    await report.save();
  } else {
    // Create new report
    report = await Report.create({
      inspectionId,
      organizationId: user.organizationId,
      currentVersion: 1,
      versions: [{
        version: 1,
        title: title || `Inspection Report - ${inspection.propertyId?.address || 'Property'}`,
        summary: summary || 'Initial inspection report generated by InspectAI',
        generatedAt: new Date(),
        generatedBy: user._id,
        watermark: true,
      }],
    });
  }

  res.status(httpStatus.CREATED).json({
    success: true,
    data: report,
    message: 'Report created. Use /generate-pdf to generate the PDF.',
  });
});

// Report PDFs are available for 7 days after generation
const REPORT_EXPIRY_DAYS = 7;
const REPORT_EXPIRY_SECONDS = REPORT_EXPIRY_DAYS * 24 * 60 * 60; // 7 days in seconds

/**
 * Calculate remaining time until report expires
 * @param {Date} generatedAt - When the PDF was generated
 * @returns {{ expired: boolean, expiresAt: Date, daysRemaining: number, hoursRemaining: number }}
 */
const calculateExpiry = (generatedAt) => {
  const expiresAt = new Date(generatedAt);
  expiresAt.setDate(expiresAt.getDate() + REPORT_EXPIRY_DAYS);
  
  const now = new Date();
  const msRemaining = expiresAt.getTime() - now.getTime();
  const expired = msRemaining <= 0;
  
  const daysRemaining = Math.max(0, Math.floor(msRemaining / (1000 * 60 * 60 * 24)));
  const hoursRemaining = Math.max(0, Math.floor((msRemaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)));
  
  return { expired, expiresAt, daysRemaining, hoursRemaining };
};

/**
 * Download inspection report as PDF
 * @route GET /v1/reports/:reportId/download
 * 
 * Reports are available for 7 days after generation.
 * After expiry, user must regenerate the report.
 */
const downloadReportPDF = catchAsync(async (req, res) => {
  const { reportId } = req.params;
  const { version } = req.query; // Optional version parameter
  const { user } = req;

  // Find report
  const report = await Report.findOne({
    _id: reportId,
    organizationId: user.organizationId,
  }).populate('inspectionId');

  if (!report) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report not found');
  }

  // Get the requested version or latest
  const requestedVersion = version ? parseInt(version, 10) : report.currentVersion;
  const reportVersion = report.versions.find(v => v.version === requestedVersion);

  if (!reportVersion) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report version not found');
  }

  // Check if report has been generated
  if (!reportVersion.generatedAt) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report PDF not yet generated. Please use /generate-pdf to create it.');
  }

  // Check expiry
  const expiry = calculateExpiry(reportVersion.generatedAt);
  
  if (expiry.expired) {
    throw new ApiError(
      httpStatus.GONE, 
      'Report has expired. Reports are available for 7 days after generation. Please regenerate the report.'
    );
  }

  // Construct the path and generate presigned URL
  const pdfPath = storagePaths.generatedReport(
    user.organizationId.toString(),
    reportId,
    requestedVersion
  );

  const storage = getStorage();
  const fileExists = await storage.exists(pdfPath).catch(() => false);

  if (fileExists) {
    // Generate presigned URL valid for remaining time or 1 hour (whichever is shorter)
    const remainingSeconds = Math.floor((expiry.expiresAt.getTime() - Date.now()) / 1000);
    const urlExpiresIn = Math.min(remainingSeconds, 3600); // Max 1 hour per download link

    const downloadUrl = await storage.getPresignedDownloadUrl(pdfPath, {
      expiresIn: urlExpiresIn,
      responseContentDisposition: `attachment; filename="inspection-report-${reportId}-v${requestedVersion}.pdf"`,
    });

    return res.json({
      success: true,
      data: { 
        downloadUrl,
        version: requestedVersion,
        filename: `inspection-report-${reportId}-v${requestedVersion}.pdf`,
        generatedAt: reportVersion.generatedAt,
        expiresAt: expiry.expiresAt,
        daysRemaining: expiry.daysRemaining,
        hoursRemaining: expiry.hoursRemaining,
        expiryMessage: expiry.daysRemaining > 1 
          ? `This report expires in ${expiry.daysRemaining} days`
          : expiry.daysRemaining === 1
          ? `This report expires tomorrow`
          : `This report expires in ${expiry.hoursRemaining} hours`,
      },
    });
  }

  // PDF doesn't exist in storage (may have been cleaned up)
  throw new ApiError(
    httpStatus.GONE, 
    'Report PDF has expired or been removed. Please regenerate the report using /generate-pdf.'
  );
});

/**
 * Generate/regenerate inspection report PDF
 * @route POST /v1/reports/:reportId/generate-pdf
 */
const generateReportPDF = catchAsync(async (req, res) => {
  const { reportId } = req.params;
  const { version: requestedVersion } = req.body; // Optional: regenerate specific version
  const { user } = req;

  // Find report with related data
  const report = await Report.findOne({
    _id: reportId,
    organizationId: user.organizationId,
  }).populate({
    path: 'inspectionId',
    populate: [
      { path: 'propertyId' },
      // Note: rooms is embedded, not a reference, so no need to populate
    ],
  });

  if (!report) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report not found');
  }

  const inspection = report.inspectionId;
  if (!inspection) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Inspection not found for this report');
  }

  // Log inspection data for debugging
  logger.info({ 
    inspectionId: inspection._id,
    hasRooms: Boolean(inspection.rooms),
    roomsCount: inspection.rooms?.length || 0,
    hasProperty: Boolean(inspection.propertyId),
    propertyAddress: inspection.propertyId?.address?.line1 || 'N/A'
  }, 'Inspection data for PDF generation');

  // Check subscription status for watermark
  const subscription = await Subscription.findOne({
    organizationId: user.organizationId,
  });
  const isTrialUser = !subscription || subscription.status !== 'active';

  // Get organization info for branding (simplified - no Organization model yet)
  const organization = { 
    _id: user.organizationId, 
    name: user.name ? `${user.name}'s Organization` : 'InspectAI',
  };

  // Get the version to generate PDF for
  const targetVersion = requestedVersion || report.currentVersion;
  const reportVersion = report.versions.find(v => v.version === targetVersion);

  if (!reportVersion) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report version not found');
  }

  // Generate PDF
  logger.info({ reportId, version: targetVersion, isTrialUser }, 'Generating PDF report');

  let pdfBuffer;
  try {
    // Safely convert inspection to object
    const inspectionData = typeof inspection.toObject === 'function' 
      ? inspection.toObject() 
      : inspection;
    
    pdfBuffer = await pdfExportService.generateInspectionReportPDF({
      inspection: {
        ...inspectionData,
        property: inspection.propertyId,
        inspector: user,
      },
      reportData: {
        title: reportVersion.title,
        summary: reportVersion.summary,
        introduction: reportVersion.introduction,
        conclusion: reportVersion.conclusion,
      },
      preset: null, // TODO: Add preset support
      organization,
      isTrialUser,
    });
  } catch (pdfError) {
    logger.error({ err: pdfError, reportId }, 'PDF generation failed');
    throw new ApiError(httpStatus.INTERNAL_SERVER_ERROR, `PDF generation failed: ${pdfError.message}`);
  }

  logger.info({ reportId, pdfSize: pdfBuffer?.length }, 'PDF buffer generated');

  // Upload to storage
  let pdfPath;
  let downloadUrl;

  try {
    pdfPath = storagePaths.generatedReport(
      user.organizationId.toString(),
      reportId,
      targetVersion
    );

    logger.info({ pdfPath }, 'Uploading PDF to storage');

    const storage = getStorage();
    await storage.upload(pdfPath, pdfBuffer, {
      contentType: 'application/pdf',
      metadata: {
        reportId: reportId,
        generatedAt: new Date().toISOString(),
        version: String(targetVersion),
      },
    });

    logger.info({ pdfPath }, 'PDF uploaded successfully');

    // Get download URL
    downloadUrl = await storage.getPresignedDownloadUrl(pdfPath, {
      expiresIn: 3600,
      responseContentDisposition: `attachment; filename="inspection-report-${reportId}-v${targetVersion}.pdf"`,
    });

    logger.info({ downloadUrl: downloadUrl?.substring(0, 100) }, 'Got presigned download URL');
  } catch (storageError) {
    logger.error({ err: storageError, pdfPath }, 'Storage operation failed');
    throw new ApiError(httpStatus.INTERNAL_SERVER_ERROR, `Storage operation failed: ${storageError.message}`);
  }

  // Update report version with PDF URL and watermark status
  const versionIndex = report.versions.findIndex(v => v.version === targetVersion);
  if (versionIndex !== -1) {
    report.versions[versionIndex].pdfUrl = downloadUrl;
    report.versions[versionIndex].watermark = isTrialUser;
    report.versions[versionIndex].generatedAt = new Date();
    await report.save();
  }

  // Mark trial usage if applicable
  if (isTrialUser && !user.trialStatus?.freeReportUsed) {
    await usageMeteringService.markFreeReportUsed(user.id, reportId);
  }

  logger.info({ reportId, pdfPath, version: targetVersion }, 'PDF report generated and uploaded');

  // Calculate expiry for the newly generated report
  const generatedAt = new Date();
  const expiresAt = new Date(generatedAt);
  expiresAt.setDate(expiresAt.getDate() + REPORT_EXPIRY_DAYS);

  res.status(httpStatus.CREATED).json({
    success: true,
    data: {
      reportId,
      version: targetVersion,
      downloadUrl,
      isTrialVersion: isTrialUser,
      generatedAt,
      expiresAt,
      daysRemaining: REPORT_EXPIRY_DAYS,
      expiryMessage: `This report will be available for ${REPORT_EXPIRY_DAYS} days. Download or regenerate before ${expiresAt.toLocaleDateString()}.`,
    },
    message: isTrialUser
      ? 'Report generated with trial watermark. Upgrade to remove watermarks.'
      : 'Report generated successfully.',
  });
});

/**
 * Stream PDF directly (for preview)
 * @route GET /v1/reports/:reportId/preview
 */
const previewReportPDF = catchAsync(async (req, res) => {
  const { reportId } = req.params;
  const { version: requestedVersion } = req.query;
  const { user } = req;

  // Find report
  const report = await Report.findOne({
    _id: reportId,
    organizationId: user.organizationId,
  }).populate({
    path: 'inspectionId',
    populate: [
      { path: 'propertyId' },
      // Note: rooms is embedded, not a reference
    ],
  });

  if (!report) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report not found');
  }

  const inspection = report.inspectionId;

  // Get the version to preview
  const targetVersion = requestedVersion ? parseInt(requestedVersion, 10) : report.currentVersion;
  const reportVersion = report.versions.find(v => v.version === targetVersion);

  if (!reportVersion) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report version not found');
  }

  // Check subscription status
  const subscription = await Subscription.findOne({
    organizationId: user.organizationId,
  });
  const isTrialUser = !subscription || subscription.status !== 'active';

  // Get organization info for branding (simplified - no Organization model yet)
  const organization = { 
    _id: user.organizationId, 
    name: user.name ? `${user.name}'s Organization` : 'InspectAI',
  };

  // Generate PDF (not saved, just for preview)
  const pdfBuffer = await pdfExportService.generateInspectionReportPDF({
    inspection: {
      ...inspection.toObject(),
      property: inspection.propertyId,
      inspector: user,
    },
    reportData: {
      title: reportVersion.title,
      summary: reportVersion.summary,
      introduction: reportVersion.introduction,
      conclusion: reportVersion.conclusion,
    },
    preset: null,
    organization,
    isTrialUser,
  });

  // Stream PDF
  res.set({
    'Content-Type': 'application/pdf',
    'Content-Disposition': `inline; filename="preview-${reportId}-v${targetVersion}.pdf"`,
    'Content-Length': pdfBuffer.length,
  });

  res.send(pdfBuffer);
});

module.exports = {
  listReports,
  getReportByInspection,
  createReport,
  downloadReportPDF,
  generateReportPDF,
  previewReportPDF,
};
