const httpStatus = require('http-status');
const catchAsync = require('../utils/catchAsync');
const ApiError = require('../utils/ApiError');
const { pdfExportService, usageMeteringService } = require('../services');
const { Inspection, Subscription, Report, ReportPreset } = require('../models');
const { getStorage, storagePaths } = require('../lib/storage');
const logger = require('../config/logger');

/**
 * Get report by inspection ID
 * @route GET /v1/reports/inspection/:inspectionId
 */
const getReportByInspection = catchAsync(async (req, res) => {
  const { inspectionId } = req.params;
  const { user } = req;

  const report = await Report.findOne({
    inspectionId,
    organizationId: user.organizationId,
  });

  if (!report) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report not found for this inspection');
  }

  res.json({
    success: true,
    data: report,
  });
});

/**
 * Create/generate report for an inspection
 * @route POST /v1/reports/inspection/:inspectionId
 */
const createReport = catchAsync(async (req, res) => {
  const { inspectionId } = req.params;
  const { title, summary } = req.body;
  const { user } = req;

  // Check if inspection exists and belongs to user's org
  // Note: rooms is embedded in inspection, not a reference, so only populate propertyId
  const inspection = await Inspection.findOne({
    _id: inspectionId,
    organizationId: user.organizationId,
  }).populate('propertyId');

  if (!inspection) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Inspection not found');
  }

  // Check if report already exists
  let report = await Report.findOne({
    inspectionId,
    organizationId: user.organizationId,
  });

  if (report) {
    // Add new version
    const newVersion = {
      version: report.currentVersion + 1,
      title: title || `Inspection Report v${report.currentVersion + 1}`,
      summary: summary || 'Report generated by InspectAI',
      generatedAt: new Date(),
      generatedBy: user._id,
      watermark: true, // Will be updated based on subscription
    };
    report.versions.push(newVersion);
    report.currentVersion += 1;
    await report.save();
  } else {
    // Create new report
    report = await Report.create({
      inspectionId,
      organizationId: user.organizationId,
      currentVersion: 1,
      versions: [{
        version: 1,
        title: title || `Inspection Report - ${inspection.propertyId?.address || 'Property'}`,
        summary: summary || 'Initial inspection report generated by InspectAI',
        generatedAt: new Date(),
        generatedBy: user._id,
        watermark: true,
      }],
    });
  }

  res.status(httpStatus.CREATED).json({
    success: true,
    data: report,
    message: 'Report created. Use /generate-pdf to generate the PDF.',
  });
});

/**
 * Download inspection report as PDF
 * @route GET /v1/reports/:reportId/download
 */
const downloadReportPDF = catchAsync(async (req, res) => {
  const { reportId } = req.params;
  const { version } = req.query; // Optional version parameter
  const { user } = req;

  // Find report
  const report = await Report.findOne({
    _id: reportId,
    organizationId: user.organizationId,
  }).populate('inspectionId');

  if (!report) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report not found');
  }

  // Get the requested version or latest
  const requestedVersion = version ? parseInt(version, 10) : report.currentVersion;
  const reportVersion = report.versions.find(v => v.version === requestedVersion);

  if (!reportVersion) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report version not found');
  }

  // If PDF URL exists, return it
  if (reportVersion.pdfUrl) {
    return res.json({
      success: true,
      data: { 
        downloadUrl: reportVersion.pdfUrl,
        version: requestedVersion,
      },
    });
  }

  // Check if PDF exists in storage
  const pdfPath = storagePaths.generatedReport(
    user.organizationId.toString(),
    reportId,
    requestedVersion
  );

  const storage = getStorage();
  const fileExists = await storage.exists(pdfPath).catch(() => false);

  if (fileExists) {
    // Get presigned URL for existing PDF
    const downloadUrl = await storage.getPresignedDownloadUrl(pdfPath, {
      expiresIn: 3600, // 1 hour
      responseContentDisposition: `attachment; filename="inspection-report-${reportId}-v${requestedVersion}.pdf"`,
    });

    return res.json({
      success: true,
      data: { 
        downloadUrl,
        version: requestedVersion,
      },
    });
  }

  // PDF doesn't exist, generate it
  throw new ApiError(httpStatus.NOT_FOUND, 'Report PDF not found. Please use /generate-pdf to create it.');
});

/**
 * Generate/regenerate inspection report PDF
 * @route POST /v1/reports/:reportId/generate-pdf
 */
const generateReportPDF = catchAsync(async (req, res) => {
  const { reportId } = req.params;
  const { version: requestedVersion } = req.body; // Optional: regenerate specific version
  const { user } = req;

  // Find report with related data
  const report = await Report.findOne({
    _id: reportId,
    organizationId: user.organizationId,
  }).populate({
    path: 'inspectionId',
    populate: [
      { path: 'propertyId' },
      // Note: rooms is embedded, not a reference, so no need to populate
    ],
  });

  if (!report) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report not found');
  }

  const inspection = report.inspectionId;
  if (!inspection) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Inspection not found for this report');
  }

  // Log inspection data for debugging
  logger.info({ 
    inspectionId: inspection._id,
    hasRooms: Boolean(inspection.rooms),
    roomsCount: inspection.rooms?.length || 0,
    hasProperty: Boolean(inspection.propertyId),
    propertyAddress: inspection.propertyId?.address?.line1 || 'N/A'
  }, 'Inspection data for PDF generation');

  // Check subscription status for watermark
  const subscription = await Subscription.findOne({
    organizationId: user.organizationId,
  });
  const isTrialUser = !subscription || subscription.status !== 'active';

  // Get organization info for branding (simplified - no Organization model yet)
  const organization = { 
    _id: user.organizationId, 
    name: user.name ? `${user.name}'s Organization` : 'InspectAI',
  };

  // Get the version to generate PDF for
  const targetVersion = requestedVersion || report.currentVersion;
  const reportVersion = report.versions.find(v => v.version === targetVersion);

  if (!reportVersion) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report version not found');
  }

  // Generate PDF
  logger.info({ reportId, version: targetVersion, isTrialUser }, 'Generating PDF report');

  let pdfBuffer;
  try {
    // Safely convert inspection to object
    const inspectionData = typeof inspection.toObject === 'function' 
      ? inspection.toObject() 
      : inspection;
    
    pdfBuffer = await pdfExportService.generateInspectionReportPDF({
      inspection: {
        ...inspectionData,
        property: inspection.propertyId,
        inspector: user,
      },
      reportData: {
        title: reportVersion.title,
        summary: reportVersion.summary,
        introduction: reportVersion.introduction,
        conclusion: reportVersion.conclusion,
      },
      preset: null, // TODO: Add preset support
      organization,
      isTrialUser,
    });
  } catch (pdfError) {
    logger.error({ err: pdfError, reportId }, 'PDF generation failed');
    throw new ApiError(httpStatus.INTERNAL_SERVER_ERROR, `PDF generation failed: ${pdfError.message}`);
  }

  logger.info({ reportId, pdfSize: pdfBuffer?.length }, 'PDF buffer generated');

  // Upload to storage
  let pdfPath;
  let downloadUrl;

  try {
    pdfPath = storagePaths.generatedReport(
      user.organizationId.toString(),
      reportId,
      targetVersion
    );

    logger.info({ pdfPath }, 'Uploading PDF to storage');

    const storage = getStorage();
    await storage.upload(pdfPath, pdfBuffer, {
      contentType: 'application/pdf',
      metadata: {
        reportId: reportId,
        generatedAt: new Date().toISOString(),
        version: String(targetVersion),
      },
    });

    logger.info({ pdfPath }, 'PDF uploaded successfully');

    // Get download URL
    downloadUrl = await storage.getPresignedDownloadUrl(pdfPath, {
      expiresIn: 3600,
      responseContentDisposition: `attachment; filename="inspection-report-${reportId}-v${targetVersion}.pdf"`,
    });

    logger.info({ downloadUrl: downloadUrl?.substring(0, 100) }, 'Got presigned download URL');
  } catch (storageError) {
    logger.error({ err: storageError, pdfPath }, 'Storage operation failed');
    throw new ApiError(httpStatus.INTERNAL_SERVER_ERROR, `Storage operation failed: ${storageError.message}`);
  }

  // Update report version with PDF URL and watermark status
  const versionIndex = report.versions.findIndex(v => v.version === targetVersion);
  if (versionIndex !== -1) {
    report.versions[versionIndex].pdfUrl = downloadUrl;
    report.versions[versionIndex].watermark = isTrialUser;
    report.versions[versionIndex].generatedAt = new Date();
    await report.save();
  }

  // Mark trial usage if applicable
  if (isTrialUser && !user.trialStatus?.freeReportUsed) {
    await usageMeteringService.markFreeReportUsed(user.id, reportId);
  }

  logger.info({ reportId, pdfPath, version: targetVersion }, 'PDF report generated and uploaded');

  res.status(httpStatus.CREATED).json({
    success: true,
    data: {
      reportId,
      version: targetVersion,
      downloadUrl,
      isTrialVersion: isTrialUser,
    },
    message: isTrialUser
      ? 'Report generated with trial watermark. Upgrade to remove watermarks.'
      : 'Report generated successfully.',
  });
});

/**
 * Stream PDF directly (for preview)
 * @route GET /v1/reports/:reportId/preview
 */
const previewReportPDF = catchAsync(async (req, res) => {
  const { reportId } = req.params;
  const { version: requestedVersion } = req.query;
  const { user } = req;

  // Find report
  const report = await Report.findOne({
    _id: reportId,
    organizationId: user.organizationId,
  }).populate({
    path: 'inspectionId',
    populate: [
      { path: 'propertyId' },
      // Note: rooms is embedded, not a reference
    ],
  });

  if (!report) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report not found');
  }

  const inspection = report.inspectionId;

  // Get the version to preview
  const targetVersion = requestedVersion ? parseInt(requestedVersion, 10) : report.currentVersion;
  const reportVersion = report.versions.find(v => v.version === targetVersion);

  if (!reportVersion) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Report version not found');
  }

  // Check subscription status
  const subscription = await Subscription.findOne({
    organizationId: user.organizationId,
  });
  const isTrialUser = !subscription || subscription.status !== 'active';

  // Get organization info for branding (simplified - no Organization model yet)
  const organization = { 
    _id: user.organizationId, 
    name: user.name ? `${user.name}'s Organization` : 'InspectAI',
  };

  // Generate PDF (not saved, just for preview)
  const pdfBuffer = await pdfExportService.generateInspectionReportPDF({
    inspection: {
      ...inspection.toObject(),
      property: inspection.propertyId,
      inspector: user,
    },
    reportData: {
      title: reportVersion.title,
      summary: reportVersion.summary,
      introduction: reportVersion.introduction,
      conclusion: reportVersion.conclusion,
    },
    preset: null,
    organization,
    isTrialUser,
  });

  // Stream PDF
  res.set({
    'Content-Type': 'application/pdf',
    'Content-Disposition': `inline; filename="preview-${reportId}-v${targetVersion}.pdf"`,
    'Content-Length': pdfBuffer.length,
  });

  res.send(pdfBuffer);
});

module.exports = {
  getReportByInspection,
  createReport,
  downloadReportPDF,
  generateReportPDF,
  previewReportPDF,
};
